#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
//破案了！！！！！不管是不是完数，每个数的真因子都会被存储入空间内，pj直接接上的可不能保证是刚确认的完数啊！！！！！！！
//我是傻比iiii
//明明是不同的判断条件，分析的时候却习惯性地混为一谈，，，反倒一直在怀疑空间布局的不可知，，，难怪一直想不出来！！！！！！


//折腾半天的程序呜呜呜呜呜
//好像没问题又根本搞不出来。。。。。。。。
//
//不对，通常都是连续的！！！！！
// 
// 
// //malloc分配的空间不一定连续，p++在一次循环中，所以，从p-m到p是可行的,但默认连续包出问题的――但问题是，为啥第一个完数打出来的就不对，明明一开始都是连续赋值的！！！
//同时，既然不失连续的，再大也不能保证不溢出吧，数据！

#define M sizeof(int)//动态分配，非指针不可吼吼
#define N (M*20)
#include <stdlib.h>//动态分配，不仅是大小够不够用的问题，灵活性使得空间利用也可“紧凑”一些
int main()
{
	int* head = (int*)malloc(1000 * N);
	int* p = head, * pj = head;
	int i, j, s, m;
	for (i = 2; i < 1000; i++)
	{
		for (j = 1, s = 0, m = 0; j < i; j++)
			if (i % j == 0)
			{
				s += j;
				*p++ = j;//p++,p是 int 的，单位就是四个字节啊！
				//printf("%5d", *(p - 1));//稍微打印试探一下，竟也没那么单纯，部分序列跟下面的错误示范竟有重合之处...怎么那么多啊！！！
				m++;
			}
		if (s == i)
		{
			printf("%4d its factors are ", i);
			for (j = 0, pj = p - m; j < m; j++)//pj=p-m真是跨时代的一步，，，可是为什么pj不能承接上次循环的位置必须这样处理？？？真的有“缓冲区”？？？几次循环不连续？
			//for (j = 0; j < m + 1; j++)//没想到竟然还有多余的。。。+2+3+4...属实不明白了！！！
			//for (j = 0; j < m; j++)
				printf("%5d", *pj++);
			printf("\n");
		}
	}
	for (i = 0; i < 17; i++)//啊啊，就是不对啊
		printf("%5d", *(head + i));
	free(head);
	return 0;
}




////这样就能大致确认开辟的的确实连续空间了，给未知的地址进行赋值*p=i可是会警告的！
////但这样下去，前面的问题就更加扑朔迷离了。。。。。。。。。。
//#define N 1000
//#include <stdlib.h>
//int main()
//{
//	int* p = (int*)malloc(sizeof(int) * N);
//	if (p == NULL)
//	{
//		perror("malloc");
//		return 1;
//	}
//	int i;
//	//果然，警告
//	/*int* pj, j = 1;
//	pj = &j;
//	*(++pj) = 5;*/
//
//	for (i = 0; i < N; i++)
//		*p++ = i + 1;
//	p = p - N;
//	for (i = 0; i < N; i++)
//		printf("%5d", *p++);
//	free(p - N);//不好，这里写free(p)包警告的啊！！！又不是首地址――没错，这也是连续的证明，由首及尾！
//	return 0;
//}